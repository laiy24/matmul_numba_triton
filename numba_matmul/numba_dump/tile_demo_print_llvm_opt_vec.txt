================================================================================
-------------------------------OPTIMIZED DUMP nrt-------------------------------
; ModuleID = 'nrt'
source_filename = "<string>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.const.pickledata.128823573851968 = internal constant [102 x i8] c"\80\04\95[\00\00\00\00\00\00\00\8C\08builtins\94\8C\0CRuntimeError\94\93\94\8C6numba jitted function aborted due to unresolved symbol\94\85\94N\87\94."
@.const.pickledata.128823573851968.sha1 = internal constant [20 x i8] c"\97\BE\DC\DF\EC\8E\80\B7\09>P\CE%\EDV\F7r\0E\0C\9C"
@.const.picklebuf.128823573851968 = internal constant { ptr, i32, ptr, ptr, i32 } { ptr @.const.pickledata.128823573851968, i32 102, ptr @.const.pickledata.128823573851968.sha1, ptr null, i32 0 }

; Function Attrs: mustprogress nofree norecurse nounwind willreturn memory(argmem: readwrite)
define i64 @nrt_atomic_add(ptr nocapture %.1) local_unnamed_addr #0 {
.3:
  %.4 = atomicrmw add ptr %.1, i64 1 monotonic, align 8
  %.5 = add i64 %.4, 1
  ret i64 %.5
}

; Function Attrs: mustprogress nofree norecurse nounwind willreturn memory(argmem: readwrite)
define i64 @nrt_atomic_sub(ptr nocapture %.1) local_unnamed_addr #0 {
.3:
  %.4 = atomicrmw sub ptr %.1, i64 1 monotonic, align 8
  %.5 = add i64 %.4, -1
  ret i64 %.5
}

; Function Attrs: mustprogress nofree norecurse nounwind willreturn memory(argmem: readwrite)
define range(i32 0, 2) i32 @nrt_atomic_cas(ptr nocapture %.1, i64 %.2, i64 %.3, ptr nocapture writeonly initializes((0, 8)) %.4) local_unnamed_addr #0 {
.6:
  %.7 = cmpxchg ptr %.1, i64 %.2, i64 %.3 monotonic monotonic, align 8
  %.8 = extractvalue { i64, i1 } %.7, 0
  %.9 = extractvalue { i64, i1 } %.7, 1
  store i64 %.8, ptr %.4, align 8
  %.11 = zext i1 %.9 to i32
  ret i32 %.11
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @NRT_MemInfo_data_fast(ptr nocapture readonly %.1) local_unnamed_addr #1 {
.3:
  %.5 = getelementptr i8, ptr %.1, i64 24
  %.6 = load ptr, ptr %.5, align 8
  ret ptr %.6
}

; Function Attrs: mustprogress nofree noinline norecurse nounwind willreturn memory(argmem: readwrite)
define void @NRT_incref(ptr %.1) local_unnamed_addr #2 {
.3:
  %.4 = icmp eq ptr %.1, null
  br i1 %.4, label %common.ret, label %.3.endif, !prof !0

common.ret:                                       ; preds = %.3, %.3.endif
  ret void

.3.endif:                                         ; preds = %.3
  %.4.i = atomicrmw add ptr %.1, i64 1 monotonic, align 8
  br label %common.ret
}

; Function Attrs: noinline
define void @NRT_decref(ptr %.1) local_unnamed_addr #3 {
.3:
  %.4 = icmp eq ptr %.1, null
  br i1 %.4, label %common.ret, label %.3.endif, !prof !0

common.ret:                                       ; preds = %.3.endif, %.3
  ret void

.3.endif:                                         ; preds = %.3
  fence release
  %0 = call i8 @llvm.x86.atomic.sub.cc.i64(ptr %.1, i64 1, i32 4)
  %1 = trunc i8 %0 to i1
  br i1 %1, label %.3.endif.if, label %common.ret, !prof !0

.3.endif.if:                                      ; preds = %.3.endif
  fence acquire
  tail call void @NRT_MemInfo_call_dtor(ptr nonnull %.1)
  ret void
}

declare void @NRT_MemInfo_call_dtor(ptr) local_unnamed_addr

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define noundef i32 @nrt_unresolved_abort(ptr nocapture readnone %.1, ptr nocapture writeonly initializes((0, 8)) %.2) local_unnamed_addr #4 {
.4:
  store ptr @.const.picklebuf.128823573851968, ptr %.2, align 8, !numba_exception_output !1
  ret i32 1
}

; Function Attrs: nounwind
declare i8 @llvm.x86.atomic.sub.cc.i64(ptr, i64, i32 immarg) #5

attributes #0 = { mustprogress nofree norecurse nounwind willreturn memory(argmem: readwrite) }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) }
attributes #2 = { mustprogress nofree noinline norecurse nounwind willreturn memory(argmem: readwrite) }
attributes #3 = { noinline }
attributes #4 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
attributes #5 = { nounwind }

!0 = !{!"branch_weights", i32 1, i32 99}
!1 = !{i1 true}

================================================================================
================================================================================
-------------------------OPTIMIZED DUMP numba_tiled_mul-------------------------
; ModuleID = 'numba_tiled_mul'
source_filename = "<string>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.const.pickledata.128823546580736 = internal constant [76 x i8] c"\80\04\95A\00\00\00\00\00\00\00\8C\08builtins\94\8C\0AValueError\94\93\94\8C\1Erange() arg 3 must not be zero\94\85\94N\87\94."
@.const.pickledata.128823546580736.sha1 = internal constant [20 x i8] c"\CA\8E\FB:r\D6\14\FE\87 2\CC\E3\AC2`\07\A3\07'"
@.const.picklebuf.128823546580736 = internal constant { ptr, i32, ptr, ptr, i32 } { ptr @.const.pickledata.128823546580736, i32 76, ptr @.const.pickledata.128823546580736.sha1, ptr null, i32 0 }
@.const.numba_tiled_mul = internal constant [16 x i8] c"numba_tiled_mul\00"
@_ZN08NumbaEnv8__main__15numba_tiled_mulB2v1B38c8tJTIeFIjxB2IKSgI4CrvQClQZ6FczSBAA_3dE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedEx = common local_unnamed_addr global ptr null
@".const.missing Environment: _ZN08NumbaEnv8__main__15numba_tiled_mulB2v1B38c8tJTIeFIjxB2IKSgI4CrvQClQZ6FczSBAA_3dE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedEx" = internal constant [201 x i8] c"missing Environment: _ZN08NumbaEnv8__main__15numba_tiled_mulB2v1B38c8tJTIeFIjxB2IKSgI4CrvQClQZ6FczSBAA_3dE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedEx\00"
@PyExc_TypeError = external global i8
@".const.can't unbox array from PyObject into native value.  The object maybe of a different type" = internal constant [89 x i8] c"can't unbox array from PyObject into native value.  The object maybe of a different type\00"
@".const.`env.consts` is NULL in `read_const`" = internal constant [37 x i8] c"`env.consts` is NULL in `read_const`\00"
@.const.pickledata.128823728961376 = internal constant [32 x i8] c"\80\04\95\15\00\00\00\00\00\00\00\8C\05numpy\94\8C\07ndarray\94\93\94."
@.const.pickledata.128823728961376.sha1 = internal constant [20 x i8] c"\DF\BC\FD\D3\9F\CB&\F4\D0\C6\80\95D\87\B8\C0\B5;\B8\A3"
@".const.Error creating Python tuple from runtime exception arguments" = internal constant [61 x i8] c"Error creating Python tuple from runtime exception arguments\00"
@PyExc_RuntimeError = external global i8
@".const.Error creating Python tuple from runtime exception arguments.1" = internal constant [61 x i8] c"Error creating Python tuple from runtime exception arguments\00"
@".const.<numba.core.cpu.CPUContext object at 0x752a11bbca10>" = internal constant [53 x i8] c"<numba.core.cpu.CPUContext object at 0x752a11bbca10>\00"

define range(i32 0, 2) i32 @_ZN8__main__15numba_tiled_mulB2v1B38c8tJTIeFIjxB2IKSgI4CrvQClQZ6FczSBAA_3dE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedEx(ptr noalias nocapture writeonly %retptr, ptr noalias nocapture writeonly %excinfo, ptr %arg.A.0, ptr nocapture readnone %arg.A.1, i64 %arg.A.2, i64 %arg.A.3, ptr nocapture readonly %arg.A.4, i64 %arg.A.5.0, i64 %arg.A.5.1, i64 %arg.A.6.0, i64 %arg.A.6.1, ptr %arg.B.0, ptr nocapture readnone %arg.B.1, i64 %arg.B.2, i64 %arg.B.3, ptr nocapture readonly %arg.B.4, i64 %arg.B.5.0, i64 %arg.B.5.1, i64 %arg.B.6.0, i64 %arg.B.6.1, ptr %arg.C.0, ptr %arg.C.1, i64 %arg.C.2, i64 %arg.C.3, ptr %arg.C.4, i64 %arg.C.5.0, i64 %arg.C.5.1, i64 %arg.C.6.0, i64 %arg.C.6.1, i64 %arg.B1) local_unnamed_addr {
B0:
  tail call void @NRT_incref(ptr %arg.A.0)
  tail call void @NRT_incref(ptr %arg.B.0)
  tail call void @NRT_incref(ptr %arg.C.0)
  %.127 = icmp eq i64 %arg.B1, 0
  br i1 %.127, label %B0.if, label %B0.endif, !prof !0

B60.loopexit:                                     ; preds = %B92.loopexit.us, %B64.endif.endif
  %.168 = icmp sgt i64 %.167674702, 1
  br i1 %.168, label %B64.endif.endif, label %B390

common.ret:                                       ; preds = %B0.if, %B390
  %common.ret.op = phi i32 [ 0, %B390 ], [ 1, %B0.if ]
  ret i32 %common.ret.op

B390:                                             ; preds = %B60.loopexit, %B0.endif, %14
  store ptr %arg.C.0, ptr %retptr, align 8
  %retptr.repack380 = getelementptr inbounds nuw i8, ptr %retptr, i64 8
  store ptr %arg.C.1, ptr %retptr.repack380, align 8
  %retptr.repack382 = getelementptr inbounds nuw i8, ptr %retptr, i64 16
  store i64 %arg.C.2, ptr %retptr.repack382, align 8
  %retptr.repack384 = getelementptr inbounds nuw i8, ptr %retptr, i64 24
  store i64 %arg.C.3, ptr %retptr.repack384, align 8
  %retptr.repack386 = getelementptr inbounds nuw i8, ptr %retptr, i64 32
  store ptr %arg.C.4, ptr %retptr.repack386, align 8
  %retptr.repack388 = getelementptr inbounds nuw i8, ptr %retptr, i64 40
  store i64 %arg.C.5.0, ptr %retptr.repack388, align 8
  %retptr.repack388.repack392 = getelementptr inbounds nuw i8, ptr %retptr, i64 48
  store i64 %arg.C.5.1, ptr %retptr.repack388.repack392, align 8
  %retptr.repack390 = getelementptr inbounds nuw i8, ptr %retptr, i64 56
  store i64 %arg.C.6.0, ptr %retptr.repack390, align 8
  %retptr.repack390.repack394 = getelementptr inbounds nuw i8, ptr %retptr, i64 64
  store i64 %arg.C.6.1, ptr %retptr.repack390.repack394, align 8
  tail call void @NRT_decref(ptr %arg.B.0)
  tail call void @NRT_decref(ptr %arg.A.0)
  br label %common.ret

B0.if:                                            ; preds = %B0
  store ptr @.const.picklebuf.128823546580736, ptr %excinfo, align 8, !numba_exception_output !1
  br label %common.ret

B0.endif:                                         ; preds = %B0
  %0 = icmp sgt i64 %arg.A.5.0, 0
  %.125 = icmp sgt i64 %arg.B1, 0
  %.126 = xor i1 %0, %.125
  br i1 %.126, label %B390, label %B0.endif.endif

B0.endif.endif:                                   ; preds = %B0.endif
  %1 = or i64 %arg.A.5.0, %arg.B1
  %2 = and i64 %1, -4294967296
  %3 = icmp eq i64 %2, 0
  br i1 %3, label %4, label %11

4:                                                ; preds = %B0.endif.endif
  %5 = trunc i64 %arg.B1 to i32
  %6 = trunc i64 %arg.A.5.0 to i32
  %7 = udiv i32 %6, %5
  %8 = urem i32 %6, %5
  %9 = zext i32 %7 to i64
  %10 = zext i32 %8 to i64
  br label %14

11:                                               ; preds = %B0.endif.endif
  %12 = sdiv i64 %arg.A.5.0, %arg.B1
  %13 = srem i64 %arg.A.5.0, %arg.B1
  br label %14

14:                                               ; preds = %11, %4
  %15 = phi i64 [ %9, %4 ], [ %12, %11 ]
  %16 = phi i64 [ %10, %4 ], [ %13, %11 ]
  %17 = icmp sgt i64 %arg.A.5.0, 0
  %.142 = sub nsw i64 0, %16
  %.143 = select i1 %17, i64 %16, i64 %.142
  %.144 = icmp sgt i64 %.143, 0
  %.146 = zext i1 %.144 to i64
  %.147 = add i64 %15, %.146
  %.168692 = icmp sgt i64 %.147, 0
  br i1 %.168692, label %B64.endif.endif.preheader, label %B390

B64.endif.endif.preheader:                        ; preds = %14
  %18 = shl i64 %arg.B1, 2
  %19 = shl i64 %arg.A.5.1, 2
  %20 = shl i64 %arg.A.5.1, 2
  %21 = shl i64 %arg.C.5.1, 2
  %22 = shl i64 %arg.C.5.1, 2
  br label %B64.endif.endif

B64.endif.endif:                                  ; preds = %B64.endif.endif.preheader, %B60.loopexit
  %.167674702 = phi i64 [ %.177, %B60.loopexit ], [ %.147, %B64.endif.endif.preheader ]
  %.174675701 = phi i64 [ %.181, %B60.loopexit ], [ 0, %B64.endif.endif.preheader ]
  %.177 = add nsw i64 %.167674702, -1
  %.181 = add i64 %.174675701, %arg.B1
  %.458 = tail call i64 @llvm.smin.i64(i64 %arg.A.5.0, i64 %.181)
  %.496 = sub i64 %.458, %.174675701
  %.496.fr = freeze i64 %.496
  %..496 = tail call i64 @llvm.smax.i64(i64 %.496.fr, i64 0)
  %.539435 = icmp sgt i64 %.496.fr, 0
  br i1 %.539435, label %B96.endif.endif.us.preheader, label %B60.loopexit

B96.endif.endif.us.preheader:                     ; preds = %B64.endif.endif
  br label %B96.endif.endif.us

B96.endif.endif.us:                               ; preds = %B96.endif.endif.us.preheader, %B92.loopexit.us
  %lsr.iv47 = phi ptr [ %arg.C.4, %B96.endif.endif.us.preheader ], [ %scevgep48, %B92.loopexit.us ]
  %lsr.iv44 = phi i64 [ 0, %B96.endif.endif.us.preheader ], [ %lsr.iv.next45, %B92.loopexit.us ]
  %lsr.iv41 = phi i64 [ %arg.B1, %B96.endif.endif.us.preheader ], [ %lsr.iv.next42, %B92.loopexit.us ]
  %indvar8 = phi i64 [ %indvar.next9, %B92.loopexit.us ], [ 0, %B96.endif.endif.us.preheader ]
  %.289541563.us = phi i64 [ %.299.us, %B92.loopexit.us ], [ %.147, %B96.endif.endif.us.preheader ]
  %.296542562.us = phi i64 [ %.303.us, %B92.loopexit.us ], [ 0, %B96.endif.endif.us.preheader ]
  %smin52 = call i64 @llvm.smin.i64(i64 %arg.A.5.0, i64 %lsr.iv41)
  %23 = add i64 %smin52, %lsr.iv44
  %smax53 = call i64 @llvm.smax.i64(i64 %23, i64 0)
  %24 = trunc i64 %smax53 to i2
  %25 = zext i2 %24 to i64
  %smin43 = call i64 @llvm.smin.i64(i64 %arg.A.5.0, i64 %lsr.iv41)
  %26 = add i64 %smin43, %lsr.iv44
  %smax46 = call i64 @llvm.smax.i64(i64 %26, i64 0)
  %27 = add i64 %arg.B1, %.296542562.us
  %smin7 = tail call i64 @llvm.smin.i64(i64 %arg.A.5.0, i64 %27)
  %28 = mul i64 %arg.B1, %indvar8
  %29 = sub i64 %smin7, %28
  %smax10 = tail call i64 @llvm.smax.i64(i64 %29, i64 0)
  %30 = add nsw i64 %smax10, -1
  %.299.us = add nsw i64 %.289541563.us, -1
  %.303.us = add i64 %.296542562.us, %arg.B1
  %.585.us = tail call i64 @llvm.smin.i64(i64 %arg.A.5.0, i64 %.303.us)
  %.623.us = sub i64 %.585.us, %.296542562.us
  %..623.us = tail call i64 @llvm.smax.i64(i64 %.623.us, i64 0)
  %.666417.us.not = icmp slt i64 %.623.us, 1
  br i1 %.666417.us.not, label %B92.loopexit.us, label %B128.endif.us.us.us.preheader

B128.endif.us.us.us.preheader:                    ; preds = %B96.endif.endif.us
  br label %B128.endif.us.us.us

B92.loopexit.us:                                  ; preds = %B180.B124.loopexit_crit_edge.split.us.us.us.us, %B96.endif.endif.us
  %indvar.next9 = add i64 %indvar8, 1
  %lsr.iv.next42 = add i64 %lsr.iv41, %arg.B1
  %lsr.iv.next45 = sub i64 %lsr.iv44, %arg.B1
  %scevgep48 = getelementptr i8, ptr %lsr.iv47, i64 %18
  %.290.us = icmp sgt i64 %.289541563.us, 1
  br i1 %.290.us, label %B96.endif.endif.us, label %B60.loopexit

B128.endif.us.us.us:                              ; preds = %B128.endif.us.us.us.preheader, %B180.B124.loopexit_crit_edge.split.us.us.us.us
  %lsr.iv19 = phi ptr [ %arg.A.4, %B128.endif.us.us.us.preheader ], [ %scevgep, %B180.B124.loopexit_crit_edge.split.us.us.us.us ]
  %lsr.iv16 = phi i64 [ 0, %B128.endif.us.us.us.preheader ], [ %lsr.iv.next17, %B180.B124.loopexit_crit_edge.split.us.us.us.us ]
  %lsr.iv = phi i64 [ %arg.B1, %B128.endif.us.us.us.preheader ], [ %lsr.iv.next, %B180.B124.loopexit_crit_edge.split.us.us.us.us ]
  %indvar = phi i64 [ 0, %B128.endif.us.us.us.preheader ], [ %indvar.next, %B180.B124.loopexit_crit_edge.split.us.us.us.us ]
  %.411474492.us.us.us = phi i64 [ %.147, %B128.endif.us.us.us.preheader ], [ %.421.us.us.us, %B180.B124.loopexit_crit_edge.split.us.us.us.us ]
  %.418475491.us.us.us = phi i64 [ 0, %B128.endif.us.us.us.preheader ], [ %.425.us.us.us, %B180.B124.loopexit_crit_edge.split.us.us.us.us ]
  %smin23 = call i64 @llvm.smin.i64(i64 %arg.A.5.0, i64 %lsr.iv)
  %31 = add i64 %smin23, %lsr.iv16
  %smax24 = call i64 @llvm.smax.i64(i64 %31, i64 0)
  %32 = trunc i64 %smax24 to i2
  %33 = zext i2 %32 to i64
  %smin15 = call i64 @llvm.smin.i64(i64 %arg.A.5.0, i64 %lsr.iv)
  %34 = add i64 %smin15, %lsr.iv16
  %smax18 = call i64 @llvm.smax.i64(i64 %34, i64 0)
  %35 = add i64 %arg.B1, %.418475491.us.us.us
  %smin = tail call i64 @llvm.smin.i64(i64 %arg.A.5.0, i64 %35)
  %36 = mul i64 %arg.B1, %indvar
  %37 = sub i64 %smin, %36
  %smax = tail call i64 @llvm.smax.i64(i64 %37, i64 0)
  %38 = add nsw i64 %smax, -1
  %.421.us.us.us = add nsw i64 %.411474492.us.us.us, -1
  %.425.us.us.us = add i64 %.418475491.us.us.us, %arg.B1
  %.715.us.us.us = tail call i64 @llvm.smin.i64(i64 %arg.A.5.0, i64 %.425.us.us.us)
  %.753.us.us.us = sub i64 %.715.us.us.us, %.418475491.us.us.us
  %..753.us.us.us = tail call i64 @llvm.smax.i64(i64 %.753.us.us.us, i64 0)
  %.796403.us.us.us.not = icmp slt i64 %.753.us.us.us, 1
  br i1 %.796403.us.us.us.not, label %B184.endif.us.us510.us.us.preheader, label %B184.endif.us.us.us.us.us.preheader

B184.endif.us.us510.us.us.preheader:              ; preds = %B128.endif.us.us.us
  br label %B184.endif.us.us510.us.us

B184.endif.us.us.us.us.us.preheader:              ; preds = %B128.endif.us.us.us
  br label %B184.endif.us.us.us.us.us

B184.endif.us.us510.us.us:                        ; preds = %B184.endif.us.us510.us.us.preheader, %B236.B180.loopexit_crit_edge.split.us458.us.us.us
  %.538427439.us.us511.us.us = phi i64 [ %.548.us.us513.us.us, %B236.B180.loopexit_crit_edge.split.us458.us.us.us ], [ %..496, %B184.endif.us.us510.us.us.preheader ]
  %.545428438.us.us512.us.us = phi i64 [ %.552.us.us514.us.us, %B236.B180.loopexit_crit_edge.split.us458.us.us.us ], [ %.174675701, %B184.endif.us.us510.us.us.preheader ]
  %39 = and i64 %smax10, 3
  %40 = icmp eq i64 %39, 0
  %.983.us.us515.us.us = icmp slt i64 %.545428438.us.us512.us.us, 0
  %.984.us.us516.us.us = select i1 %.983.us.us515.us.us, i64 %arg.C.5.0, i64 0
  br i1 %40, label %B240.endif.us445.us.us.us.prol.loopexit, label %B240.endif.us445.us.us.us.prol.preheader

B240.endif.us445.us.us.us.prol.preheader:         ; preds = %B184.endif.us.us510.us.us
  %41 = add i64 %.984.us.us516.us.us, %.545428438.us.us512.us.us
  %42 = mul i64 %21, %41
  %scevgep49 = getelementptr i8, ptr %lsr.iv47, i64 %42
  br label %B240.endif.us445.us.us.us.prol

B240.endif.us445.us.us.us.prol:                   ; preds = %B240.endif.us445.us.us.us.prol.preheader, %B240.endif.us445.us.us.us.prol
  %prol.iter13 = phi i64 [ %prol.iter13.next, %B240.endif.us445.us.us.us.prol ], [ 0, %B240.endif.us445.us.us.us.prol.preheader ]
  %43 = add i64 %.296542562.us, %prol.iter13
  %.986.us450.us.us.us.prol = icmp slt i64 %43, 0
  %.987.us451.us.us.us.prol = select i1 %.986.us450.us.us.us.prol, i64 %arg.C.5.1, i64 0
  %44 = shl i64 %.987.us451.us.us.us.prol, 2
  %scevgep50 = getelementptr i8, ptr %scevgep49, i64 %44
  %45 = shl nuw nsw i64 %prol.iter13, 2
  %scevgep51 = getelementptr i8, ptr %scevgep50, i64 %45
  %.1010.us453.us.us.us714.prol = load float, ptr %scevgep51, align 4
  %.1063.us456.us.us.us.prol = fadd float %.1010.us453.us.us.us714.prol, 0.000000e+00
  store float %.1063.us456.us.us.us.prol, ptr %scevgep51, align 4
  %prol.iter13.next = add i64 %prol.iter13, 1
  %prol.iter13.cmp.not = icmp eq i64 %25, %prol.iter13.next
  br i1 %prol.iter13.cmp.not, label %B240.endif.us445.us.us.us.prol.loopexit.loopexit, label %B240.endif.us445.us.us.us.prol, !llvm.loop !2

B240.endif.us445.us.us.us.prol.loopexit.loopexit: ; preds = %B240.endif.us445.us.us.us.prol
  %46 = sub i64 %smax46, %prol.iter13.next
  %47 = add i64 %.296542562.us, %prol.iter13.next
  br label %B240.endif.us445.us.us.us.prol.loopexit

B240.endif.us445.us.us.us.prol.loopexit:          ; preds = %B240.endif.us445.us.us.us.prol.loopexit.loopexit, %B184.endif.us.us510.us.us
  %.665411419.us446.us.us.us.unr = phi i64 [ %..623.us, %B184.endif.us.us510.us.us ], [ %46, %B240.endif.us445.us.us.us.prol.loopexit.loopexit ]
  %.672412418.us447.us.us.us.unr = phi i64 [ %.296542562.us, %B184.endif.us.us510.us.us ], [ %47, %B240.endif.us445.us.us.us.prol.loopexit.loopexit ]
  %48 = icmp ult i64 %30, 3
  br i1 %48, label %B236.B180.loopexit_crit_edge.split.us458.us.us.us, label %B240.endif.us445.us.us.us.preheader

B240.endif.us445.us.us.us.preheader:              ; preds = %B240.endif.us445.us.us.us.prol.loopexit
  %49 = add i64 %.665411419.us446.us.us.us.unr, 4
  %50 = add i64 %.984.us.us516.us.us, %.545428438.us.us512.us.us
  %51 = mul i64 %22, %50
  %scevgep56 = getelementptr i8, ptr %arg.C.4, i64 %51
  br label %B240.endif.us445.us.us.us

B240.endif.us445.us.us.us:                        ; preds = %B240.endif.us445.us.us.us.preheader, %B240.endif.us445.us.us.us
  %lsr.iv54 = phi i64 [ %49, %B240.endif.us445.us.us.us.preheader ], [ %lsr.iv.next55, %B240.endif.us445.us.us.us ]
  %.672412418.us447.us.us.us = phi i64 [ %63, %B240.endif.us445.us.us.us ], [ %.672412418.us447.us.us.us.unr, %B240.endif.us445.us.us.us.preheader ]
  %.986.us450.us.us.us = icmp slt i64 %.672412418.us447.us.us.us, 0
  %.987.us451.us.us.us = select i1 %.986.us450.us.us.us, i64 %arg.C.5.1, i64 0
  %52 = shl i64 %.987.us451.us.us.us, 2
  %scevgep63 = getelementptr i8, ptr %scevgep56, i64 %52
  %53 = shl i64 %.672412418.us447.us.us.us, 2
  %scevgep64 = getelementptr i8, ptr %scevgep63, i64 %53
  %.1010.us453.us.us.us714 = load float, ptr %scevgep64, align 4
  %.1063.us456.us.us.us = fadd float %.1010.us453.us.us.us714, 0.000000e+00
  store float %.1063.us456.us.us.us, ptr %scevgep64, align 4
  %54 = add i64 %.672412418.us447.us.us.us, 1
  %.986.us450.us.us.us.1 = icmp slt i64 %54, 0
  %.987.us451.us.us.us.1 = select i1 %.986.us450.us.us.us.1, i64 %arg.C.5.1, i64 0
  %55 = shl i64 %.987.us451.us.us.us.1, 2
  %scevgep65 = getelementptr i8, ptr %scevgep56, i64 %55
  %56 = shl i64 %.672412418.us447.us.us.us, 2
  %scevgep66 = getelementptr i8, ptr %scevgep65, i64 %56
  %scevgep67 = getelementptr i8, ptr %scevgep66, i64 4
  %.1010.us453.us.us.us714.1 = load float, ptr %scevgep67, align 4
  %.1063.us456.us.us.us.1 = fadd float %.1010.us453.us.us.us714.1, 0.000000e+00
  store float %.1063.us456.us.us.us.1, ptr %scevgep67, align 4
  %57 = add i64 %54, 1
  %.986.us450.us.us.us.2 = icmp slt i64 %57, 0
  %.987.us451.us.us.us.2 = select i1 %.986.us450.us.us.us.2, i64 %arg.C.5.1, i64 0
  %58 = shl i64 %.987.us451.us.us.us.2, 2
  %scevgep60 = getelementptr i8, ptr %scevgep56, i64 %58
  %59 = shl i64 %.672412418.us447.us.us.us, 2
  %scevgep61 = getelementptr i8, ptr %scevgep60, i64 %59
  %scevgep62 = getelementptr i8, ptr %scevgep61, i64 8
  %.1010.us453.us.us.us714.2 = load float, ptr %scevgep62, align 4
  %.1063.us456.us.us.us.2 = fadd float %.1010.us453.us.us.us714.2, 0.000000e+00
  store float %.1063.us456.us.us.us.2, ptr %scevgep62, align 4
  %60 = add i64 %57, 1
  %.986.us450.us.us.us.3 = icmp slt i64 %60, 0
  %.987.us451.us.us.us.3 = select i1 %.986.us450.us.us.us.3, i64 %arg.C.5.1, i64 0
  %61 = shl i64 %.987.us451.us.us.us.3, 2
  %scevgep57 = getelementptr i8, ptr %scevgep56, i64 %61
  %62 = shl i64 %.672412418.us447.us.us.us, 2
  %scevgep58 = getelementptr i8, ptr %scevgep57, i64 %62
  %scevgep59 = getelementptr i8, ptr %scevgep58, i64 12
  %.1010.us453.us.us.us714.3 = load float, ptr %scevgep59, align 4
  %.1063.us456.us.us.us.3 = fadd float %.1010.us453.us.us.us714.3, 0.000000e+00
  store float %.1063.us456.us.us.us.3, ptr %scevgep59, align 4
  %lsr.iv.next55 = add i64 %lsr.iv54, -4
  %.666.us457.us.us.us.3 = icmp sgt i64 %lsr.iv.next55, 4
  %63 = add i64 %60, 1
  br i1 %.666.us457.us.us.us.3, label %B240.endif.us445.us.us.us, label %B236.B180.loopexit_crit_edge.split.us458.us.us.us

B236.B180.loopexit_crit_edge.split.us458.us.us.us: ; preds = %B240.endif.us445.us.us.us, %B240.endif.us445.us.us.us.prol.loopexit
  %.548.us.us513.us.us = add nsw i64 %.538427439.us.us511.us.us, -1
  %.552.us.us514.us.us = add i64 %.545428438.us.us512.us.us, 1
  %.539.us.us519.us.us = icmp sgt i64 %.538427439.us.us511.us.us, 1
  br i1 %.539.us.us519.us.us, label %B184.endif.us.us510.us.us, label %B180.B124.loopexit_crit_edge.split.us.us.us.us

B180.B124.loopexit_crit_edge.split.us.us.us.us:   ; preds = %B236.B180.loopexit_crit_edge.split.us.us.us.us.us.us, %B236.B180.loopexit_crit_edge.split.us458.us.us.us
  %indvar.next = add i64 %indvar, 1
  %lsr.iv.next = add i64 %lsr.iv, %arg.B1
  %lsr.iv.next17 = sub i64 %lsr.iv16, %arg.B1
  %scevgep = getelementptr i8, ptr %lsr.iv19, i64 %18
  %.412.us.us.us = icmp sgt i64 %.411474492.us.us.us, 1
  br i1 %.412.us.us.us, label %B128.endif.us.us.us, label %B92.loopexit.us

B184.endif.us.us.us.us.us:                        ; preds = %B184.endif.us.us.us.us.us.preheader, %B236.B180.loopexit_crit_edge.split.us.us.us.us.us.us
  %.538427439.us.us.us.us.us = phi i64 [ %.548.us.us.us.us.us, %B236.B180.loopexit_crit_edge.split.us.us.us.us.us.us ], [ %..496, %B184.endif.us.us.us.us.us.preheader ]
  %.545428438.us.us.us.us.us = phi i64 [ %.552.us.us.us.us.us, %B236.B180.loopexit_crit_edge.split.us.us.us.us.us.us ], [ %.174675701, %B184.endif.us.us.us.us.us.preheader ]
  %.859.us.us.us.us.us = icmp slt i64 %.545428438.us.us.us.us.us, 0
  %.860.us.us.us.us.us = select i1 %.859.us.us.us.us.us, i64 %arg.A.5.0, i64 0
  %.984.us.us.us.us.us = select i1 %.859.us.us.us.us.us, i64 %arg.C.5.0, i64 0
  %.985.us.us.us.us.us = add i64 %.984.us.us.us.us.us, %.545428438.us.us.us.us.us
  %.1005.us.us.us.us.us = mul i64 %.985.us.us.us.us.us, %arg.C.5.1
  %64 = getelementptr float, ptr %arg.C.4, i64 %.1005.us.us.us.us.us
  %65 = add i64 %.860.us.us.us.us.us, %.545428438.us.us.us.us.us
  %66 = mul i64 %19, %65
  %scevgep20 = getelementptr i8, ptr %lsr.iv19, i64 %66
  %67 = mul i64 %20, %65
  %scevgep29 = getelementptr i8, ptr %arg.A.4, i64 %67
  br label %B240.endif.us.us.us.us.us.us

B240.endif.us.us.us.us.us.us:                     ; preds = %B296.B340_crit_edge.us.us.us.us.us.us, %B184.endif.us.us.us.us.us
  %.665411419.us.us.us.us.us.us = phi i64 [ %..623.us, %B184.endif.us.us.us.us.us ], [ %.675.us.us.us.us.us.us, %B296.B340_crit_edge.us.us.us.us.us.us ]
  %.672412418.us.us.us.us.us.us = phi i64 [ %.296542562.us, %B184.endif.us.us.us.us.us ], [ %.679.us.us.us.us.us.us, %B296.B340_crit_edge.us.us.us.us.us.us ]
  %68 = and i64 %smax, 3
  %69 = icmp eq i64 %68, 0
  %invariant.gep.us.us.us.us.us.us = getelementptr float, ptr %arg.B.4, i64 %.672412418.us.us.us.us.us.us
  %.917.us.us.us.us.us.us = icmp slt i64 %.672412418.us.us.us.us.us.us, 0
  %.918.us.us.us.us.us.us = select i1 %.917.us.us.us.us.us.us, i64 %arg.B.5.1, i64 0
  %invariant.gep409.us.us.us.us.us.us = getelementptr float, ptr %invariant.gep.us.us.us.us.us.us, i64 %.918.us.us.us.us.us.us
  br i1 %69, label %B300.us.us.us.us.us.us.prol.loopexit, label %B300.us.us.us.us.us.us.prol.preheader

B300.us.us.us.us.us.us.prol.preheader:            ; preds = %B240.endif.us.us.us.us.us.us
  br label %B300.us.us.us.us.us.us.prol

B300.us.us.us.us.us.us.prol:                      ; preds = %B300.us.us.us.us.us.us.prol.preheader, %B300.us.us.us.us.us.us.prol
  %tmp.2.5406.us.us.us.us.us.us.prol = phi double [ %.947.us.us.us.us.us.us.prol, %B300.us.us.us.us.us.us.prol ], [ 0.000000e+00, %B300.us.us.us.us.us.us.prol.preheader ]
  %prol.iter = phi i64 [ %prol.iter.next, %B300.us.us.us.us.us.us.prol ], [ 0, %B300.us.us.us.us.us.us.prol.preheader ]
  %70 = add i64 %.418475491.us.us.us, %prol.iter
  %.862.us.us.us.us.us.us.prol = icmp slt i64 %70, 0
  %.863.us.us.us.us.us.us.prol = select i1 %.862.us.us.us.us.us.us.prol, i64 %arg.A.5.1, i64 0
  %71 = shl i64 %.863.us.us.us.us.us.us.prol, 2
  %scevgep21 = getelementptr i8, ptr %scevgep20, i64 %71
  %72 = shl nuw nsw i64 %prol.iter, 2
  %scevgep22 = getelementptr i8, ptr %scevgep21, i64 %72
  %.886.us.us.us.us.us.us.prol = load float, ptr %scevgep22, align 4
  %.915.us.us.us.us.us.us.prol = select i1 %.862.us.us.us.us.us.us.prol, i64 %arg.B.5.0, i64 0
  %73 = add i64 %.418475491.us.us.us, %.915.us.us.us.us.us.us.prol
  %74 = add i64 %73, %prol.iter
  %.936.us.us.us.us.us.us.prol = mul i64 %74, %arg.B.5.1
  %gep410.us.us.us.us.us.us.prol = getelementptr float, ptr %invariant.gep409.us.us.us.us.us.us, i64 %.936.us.us.us.us.us.us.prol
  %.941.us.us.us.us.us.us.prol = load float, ptr %gep410.us.us.us.us.us.us.prol, align 4
  %.944.us.us.us.us.us.us.prol = fmul float %.886.us.us.us.us.us.us.prol, %.941.us.us.us.us.us.us.prol
  %.946.us.us.us.us.us.us.prol = fpext float %.944.us.us.us.us.us.us.prol to double
  %.947.us.us.us.us.us.us.prol = fadd double %tmp.2.5406.us.us.us.us.us.us.prol, %.946.us.us.us.us.us.us.prol
  %prol.iter.next = add i64 %prol.iter, 1
  %prol.iter.cmp.not = icmp eq i64 %33, %prol.iter.next
  br i1 %prol.iter.cmp.not, label %B300.us.us.us.us.us.us.prol.loopexit.loopexit, label %B300.us.us.us.us.us.us.prol, !llvm.loop !4

B300.us.us.us.us.us.us.prol.loopexit.loopexit:    ; preds = %B300.us.us.us.us.us.us.prol
  %75 = sub i64 %smax18, %prol.iter.next
  %76 = add i64 %.418475491.us.us.us, %prol.iter.next
  br label %B300.us.us.us.us.us.us.prol.loopexit

B300.us.us.us.us.us.us.prol.loopexit:             ; preds = %B300.us.us.us.us.us.us.prol.loopexit.loopexit, %B240.endif.us.us.us.us.us.us
  %tmp.2.5406.us.us.us.us.us.us.unr = phi double [ 0.000000e+00, %B240.endif.us.us.us.us.us.us ], [ %.947.us.us.us.us.us.us.prol, %B300.us.us.us.us.us.us.prol.loopexit.loopexit ]
  %.795401405.us.us.us.us.us.us.unr = phi i64 [ %..753.us.us.us, %B240.endif.us.us.us.us.us.us ], [ %75, %B300.us.us.us.us.us.us.prol.loopexit.loopexit ]
  %.802402404.us.us.us.us.us.us.unr = phi i64 [ %.418475491.us.us.us, %B240.endif.us.us.us.us.us.us ], [ %76, %B300.us.us.us.us.us.us.prol.loopexit.loopexit ]
  %.947.us.us.us.us.us.us.lcssa.unr = phi double [ poison, %B240.endif.us.us.us.us.us.us ], [ %.947.us.us.us.us.us.us.prol, %B300.us.us.us.us.us.us.prol.loopexit.loopexit ]
  %77 = icmp ult i64 %38, 3
  br i1 %77, label %B296.B340_crit_edge.us.us.us.us.us.us, label %B300.us.us.us.us.us.us.preheader

B300.us.us.us.us.us.us.preheader:                 ; preds = %B300.us.us.us.us.us.us.prol.loopexit
  %78 = add i64 %.795401405.us.us.us.us.us.us.unr, 4
  %79 = add i64 %.802402404.us.us.us.us.us.us.unr, 3
  br label %B300.us.us.us.us.us.us

B300.us.us.us.us.us.us:                           ; preds = %B300.us.us.us.us.us.us.preheader, %B300.us.us.us.us.us.us
  %lsr.iv27 = phi i64 [ %79, %B300.us.us.us.us.us.us.preheader ], [ %lsr.iv.next28, %B300.us.us.us.us.us.us ]
  %lsr.iv25 = phi i64 [ %78, %B300.us.us.us.us.us.us.preheader ], [ %lsr.iv.next26, %B300.us.us.us.us.us.us ]
  %tmp.2.5406.us.us.us.us.us.us = phi double [ %.947.us.us.us.us.us.us.3, %B300.us.us.us.us.us.us ], [ %tmp.2.5406.us.us.us.us.us.us.unr, %B300.us.us.us.us.us.us.preheader ]
  %80 = add i64 %lsr.iv27, -3
  %.862.us.us.us.us.us.us = icmp slt i64 %80, 0
  %.863.us.us.us.us.us.us = select i1 %.862.us.us.us.us.us.us, i64 %arg.A.5.1, i64 0
  %81 = shl i64 %.863.us.us.us.us.us.us, 2
  %scevgep35 = getelementptr i8, ptr %scevgep29, i64 %81
  %82 = shl i64 %lsr.iv27, 2
  %scevgep36 = getelementptr i8, ptr %scevgep35, i64 %82
  %scevgep37 = getelementptr i8, ptr %scevgep36, i64 -12
  %.886.us.us.us.us.us.us = load float, ptr %scevgep37, align 4
  %.915.us.us.us.us.us.us = select i1 %.862.us.us.us.us.us.us, i64 %arg.B.5.0, i64 0
  %83 = add i64 %.915.us.us.us.us.us.us, %lsr.iv27
  %84 = add i64 %83, -3
  %.936.us.us.us.us.us.us = mul i64 %84, %arg.B.5.1
  %gep410.us.us.us.us.us.us = getelementptr float, ptr %invariant.gep409.us.us.us.us.us.us, i64 %.936.us.us.us.us.us.us
  %.941.us.us.us.us.us.us = load float, ptr %gep410.us.us.us.us.us.us, align 4
  %.944.us.us.us.us.us.us = fmul float %.886.us.us.us.us.us.us, %.941.us.us.us.us.us.us
  %.946.us.us.us.us.us.us = fpext float %.944.us.us.us.us.us.us to double
  %.947.us.us.us.us.us.us = fadd double %tmp.2.5406.us.us.us.us.us.us, %.946.us.us.us.us.us.us
  %85 = add i64 %80, 1
  %.862.us.us.us.us.us.us.1 = icmp slt i64 %85, 0
  %.863.us.us.us.us.us.us.1 = select i1 %.862.us.us.us.us.us.us.1, i64 %arg.A.5.1, i64 0
  %86 = shl i64 %.863.us.us.us.us.us.us.1, 2
  %scevgep38 = getelementptr i8, ptr %scevgep29, i64 %86
  %87 = shl i64 %lsr.iv27, 2
  %scevgep39 = getelementptr i8, ptr %scevgep38, i64 %87
  %scevgep40 = getelementptr i8, ptr %scevgep39, i64 -8
  %.886.us.us.us.us.us.us.1 = load float, ptr %scevgep40, align 4
  %.915.us.us.us.us.us.us.1 = select i1 %.862.us.us.us.us.us.us.1, i64 %arg.B.5.0, i64 0
  %88 = add i64 %.915.us.us.us.us.us.us.1, %lsr.iv27
  %89 = add i64 %88, -2
  %.936.us.us.us.us.us.us.1 = mul i64 %89, %arg.B.5.1
  %gep410.us.us.us.us.us.us.1 = getelementptr float, ptr %invariant.gep409.us.us.us.us.us.us, i64 %.936.us.us.us.us.us.us.1
  %.941.us.us.us.us.us.us.1 = load float, ptr %gep410.us.us.us.us.us.us.1, align 4
  %.944.us.us.us.us.us.us.1 = fmul float %.886.us.us.us.us.us.us.1, %.941.us.us.us.us.us.us.1
  %.946.us.us.us.us.us.us.1 = fpext float %.944.us.us.us.us.us.us.1 to double
  %.947.us.us.us.us.us.us.1 = fadd double %.947.us.us.us.us.us.us, %.946.us.us.us.us.us.us.1
  %90 = add i64 %85, 1
  %.862.us.us.us.us.us.us.2 = icmp slt i64 %90, 0
  %.863.us.us.us.us.us.us.2 = select i1 %.862.us.us.us.us.us.us.2, i64 %arg.A.5.1, i64 0
  %91 = shl i64 %.863.us.us.us.us.us.us.2, 2
  %scevgep32 = getelementptr i8, ptr %scevgep29, i64 %91
  %92 = shl i64 %lsr.iv27, 2
  %scevgep33 = getelementptr i8, ptr %scevgep32, i64 %92
  %scevgep34 = getelementptr i8, ptr %scevgep33, i64 -4
  %.886.us.us.us.us.us.us.2 = load float, ptr %scevgep34, align 4
  %.915.us.us.us.us.us.us.2 = select i1 %.862.us.us.us.us.us.us.2, i64 %arg.B.5.0, i64 0
  %93 = add i64 %.915.us.us.us.us.us.us.2, %lsr.iv27
  %94 = add i64 %93, -1
  %.936.us.us.us.us.us.us.2 = mul i64 %94, %arg.B.5.1
  %gep410.us.us.us.us.us.us.2 = getelementptr float, ptr %invariant.gep409.us.us.us.us.us.us, i64 %.936.us.us.us.us.us.us.2
  %.941.us.us.us.us.us.us.2 = load float, ptr %gep410.us.us.us.us.us.us.2, align 4
  %.944.us.us.us.us.us.us.2 = fmul float %.886.us.us.us.us.us.us.2, %.941.us.us.us.us.us.us.2
  %.946.us.us.us.us.us.us.2 = fpext float %.944.us.us.us.us.us.us.2 to double
  %.947.us.us.us.us.us.us.2 = fadd double %.947.us.us.us.us.us.us.1, %.946.us.us.us.us.us.us.2
  %95 = add i64 %90, 1
  %.862.us.us.us.us.us.us.3 = icmp slt i64 %95, 0
  %.863.us.us.us.us.us.us.3 = select i1 %.862.us.us.us.us.us.us.3, i64 %arg.A.5.1, i64 0
  %96 = shl i64 %.863.us.us.us.us.us.us.3, 2
  %scevgep30 = getelementptr i8, ptr %scevgep29, i64 %96
  %97 = shl i64 %lsr.iv27, 2
  %scevgep31 = getelementptr i8, ptr %scevgep30, i64 %97
  %.886.us.us.us.us.us.us.3 = load float, ptr %scevgep31, align 4
  %.915.us.us.us.us.us.us.3 = select i1 %.862.us.us.us.us.us.us.3, i64 %arg.B.5.0, i64 0
  %98 = add i64 %.915.us.us.us.us.us.us.3, %lsr.iv27
  %.936.us.us.us.us.us.us.3 = mul i64 %98, %arg.B.5.1
  %gep410.us.us.us.us.us.us.3 = getelementptr float, ptr %invariant.gep409.us.us.us.us.us.us, i64 %.936.us.us.us.us.us.us.3
  %.941.us.us.us.us.us.us.3 = load float, ptr %gep410.us.us.us.us.us.us.3, align 4
  %.944.us.us.us.us.us.us.3 = fmul float %.886.us.us.us.us.us.us.3, %.941.us.us.us.us.us.us.3
  %.946.us.us.us.us.us.us.3 = fpext float %.944.us.us.us.us.us.us.3 to double
  %.947.us.us.us.us.us.us.3 = fadd double %.947.us.us.us.us.us.us.2, %.946.us.us.us.us.us.us.3
  %lsr.iv.next26 = add i64 %lsr.iv25, -4
  %lsr.iv.next28 = add i64 %lsr.iv27, 4
  %.796.us.us.us.us.us.us.3 = icmp sgt i64 %lsr.iv.next26, 4
  br i1 %.796.us.us.us.us.us.us.3, label %B300.us.us.us.us.us.us, label %B296.B340_crit_edge.us.us.us.us.us.us

B296.B340_crit_edge.us.us.us.us.us.us:            ; preds = %B300.us.us.us.us.us.us, %B300.us.us.us.us.us.us.prol.loopexit
  %.947.us.us.us.us.us.us.lcssa = phi double [ %.947.us.us.us.us.us.us.lcssa.unr, %B300.us.us.us.us.us.us.prol.loopexit ], [ %.947.us.us.us.us.us.us.3, %B300.us.us.us.us.us.us ]
  %99 = icmp slt i64 %.672412418.us.us.us.us.us.us, 0
  %.675.us.us.us.us.us.us = add nsw i64 %.665411419.us.us.us.us.us.us, -1
  %.679.us.us.us.us.us.us = add i64 %.672412418.us.us.us.us.us.us, 1
  %.987.us.us.us.us.us.us = select i1 %99, i64 %arg.C.5.1, i64 0
  %100 = getelementptr float, ptr %64, i64 %.672412418.us.us.us.us.us.us
  %.1009.us.us.us.us.us.us = getelementptr float, ptr %100, i64 %.987.us.us.us.us.us.us
  %.1010.us.us.us.us.us.us = load float, ptr %.1009.us.us.us.us.us.us, align 4
  %.1012.us.us.us.us.us.us = fpext float %.1010.us.us.us.us.us.us to double
  %.1013.us.us.us.us.us.us = fadd double %.947.us.us.us.us.us.us.lcssa, %.1012.us.us.us.us.us.us
  %.1063.us.us.us.us.us.us = fptrunc double %.1013.us.us.us.us.us.us to float
  store float %.1063.us.us.us.us.us.us, ptr %.1009.us.us.us.us.us.us, align 4
  %.666.us.us.us.us.us.us = icmp sgt i64 %.665411419.us.us.us.us.us.us, 1
  br i1 %.666.us.us.us.us.us.us, label %B240.endif.us.us.us.us.us.us, label %B236.B180.loopexit_crit_edge.split.us.us.us.us.us.us

B236.B180.loopexit_crit_edge.split.us.us.us.us.us.us: ; preds = %B296.B340_crit_edge.us.us.us.us.us.us
  %.548.us.us.us.us.us = add nsw i64 %.538427439.us.us.us.us.us, -1
  %.552.us.us.us.us.us = add i64 %.545428438.us.us.us.us.us, 1
  %.539.us.us.us.us.us = icmp sgt i64 %.538427439.us.us.us.us.us, 1
  br i1 %.539.us.us.us.us.us, label %B184.endif.us.us.us.us.us, label %B180.B124.loopexit_crit_edge.split.us.us.us.us
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smin.i64(i64, i64) #0

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #0

define ptr @_ZN7cpython8__main__15numba_tiled_mulB2v1B38c8tJTIeFIjxB2IKSgI4CrvQClQZ6FczSBAA_3dE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedEx(ptr nocapture readnone %py_closure, ptr %py_args, ptr nocapture readnone %py_kws) local_unnamed_addr {
entry:
  %.5 = alloca ptr, align 8
  %.6 = alloca ptr, align 8
  %.7 = alloca ptr, align 8
  %.8 = alloca ptr, align 8
  %.9 = call i32 (ptr, ptr, i64, i64, ...) @PyArg_UnpackTuple(ptr %py_args, ptr nonnull @.const.numba_tiled_mul, i64 4, i64 4, ptr nonnull %.5, ptr nonnull %.6, ptr nonnull %.7, ptr nonnull %.8)
  %.10 = icmp eq i32 %.9, 0
  %.24 = alloca { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] }, align 8
  %.49 = alloca { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] }, align 8
  %.74 = alloca { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] }, align 8
  %.114 = alloca { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] }, align 16
  %excinfo = alloca ptr, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(72) %.114, i8 0, i64 72, i1 false)
  store ptr null, ptr %excinfo, align 8
  %.199 = alloca { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] }, align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(72) %.199, i8 0, i64 72, i1 false)
  br i1 %.10, label %common.ret, label %entry.endif, !prof !0

common.ret:                                       ; preds = %entry.endif.endif.endif.e...if.2, %entry.endif.endif.endif.e...endif.endif.endif.if.endif, %arg0.err, %entry.endif.endif.endif, %entry, %entry.endif.endif.endif.e...if.1, %entry.endif.endif.endif.e...endif.endif.if.endif.endif, %entry.endif.if
  %common.ret.op = phi ptr [ null, %entry.endif.if ], [ %.203, %entry.endif.endif.endif.e...endif.endif.if.endif.endif ], [ null, %entry.endif.endif.endif.e...if.1 ], [ null, %entry ], [ null, %entry.endif.endif.endif ], [ null, %arg0.err ], [ null, %entry.endif.endif.endif.e...endif.endif.endif.if.endif ], [ null, %entry.endif.endif.endif.e...if.2 ]
  ret ptr %common.ret.op

entry.endif:                                      ; preds = %entry
  %.14 = load ptr, ptr @_ZN08NumbaEnv8__main__15numba_tiled_mulB2v1B38c8tJTIeFIjxB2IKSgI4CrvQClQZ6FczSBAA_3dE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedEx, align 8
  %.19 = icmp eq ptr %.14, null
  br i1 %.19, label %entry.endif.if, label %entry.endif.endif, !prof !0

entry.endif.if:                                   ; preds = %entry.endif
  call void @PyErr_SetString(ptr nonnull @PyExc_RuntimeError, ptr nonnull @".const.missing Environment: _ZN08NumbaEnv8__main__15numba_tiled_mulB2v1B38c8tJTIeFIjxB2IKSgI4CrvQClQZ6FczSBAA_3dE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedEx")
  br label %common.ret

entry.endif.endif:                                ; preds = %entry.endif
  %.23 = load ptr, ptr %.5, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(72) %.24, i8 0, i64 72, i1 false)
  %.28 = call i32 @NRT_adapt_ndarray_from_python(ptr %.23, ptr nonnull %.24)
  %sunkaddr = getelementptr inbounds i8, ptr %.24, i64 24
  %.32 = load i64, ptr %sunkaddr, align 8
  %.33 = icmp ne i64 %.32, 4
  %.34 = icmp ne i32 %.28, 0
  %.35 = or i1 %.34, %.33
  br i1 %.35, label %entry.endif.endif.if, label %entry.endif.endif.endif, !prof !0

entry.endif.endif.if:                             ; preds = %entry.endif.endif
  call void @PyErr_SetString(ptr nonnull @PyExc_TypeError, ptr nonnull @".const.can't unbox array from PyObject into native value.  The object maybe of a different type")
  br label %entry.endif.endif.endif

entry.endif.endif.endif:                          ; preds = %entry.endif.endif.if, %entry.endif.endif
  %.39.fca.0.load = load ptr, ptr %.24, align 8
  %sunkaddr1 = getelementptr inbounds i8, ptr %.24, i64 32
  %.39.fca.4.load = load ptr, ptr %sunkaddr1, align 8
  %sunkaddr2 = getelementptr inbounds i8, ptr %.24, i64 40
  %.39.fca.5.0.load = load i64, ptr %sunkaddr2, align 8
  %sunkaddr3 = getelementptr inbounds i8, ptr %.24, i64 48
  %.39.fca.5.1.load = load i64, ptr %sunkaddr3, align 8
  br i1 %.35, label %common.ret, label %entry.endif.endif.endif.endif, !prof !0

entry.endif.endif.endif.endif:                    ; preds = %entry.endif.endif.endif
  %.48 = load ptr, ptr %.6, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(72) %.49, i8 0, i64 72, i1 false)
  %.53 = call i32 @NRT_adapt_ndarray_from_python(ptr %.48, ptr nonnull %.49)
  %sunkaddr4 = getelementptr inbounds i8, ptr %.49, i64 24
  %.57 = load i64, ptr %sunkaddr4, align 8
  %.58 = icmp ne i64 %.57, 4
  %.59 = icmp ne i32 %.53, 0
  %.60 = or i1 %.59, %.58
  br i1 %.60, label %entry.endif.endif.endif.endif.if, label %entry.endif.endif.endif.endif.endif, !prof !0

arg0.err:                                         ; preds = %entry.endif.endif.endif.endif.endif, %arg1.err
  call void @NRT_decref(ptr %.39.fca.0.load)
  br label %common.ret

entry.endif.endif.endif.endif.if:                 ; preds = %entry.endif.endif.endif.endif
  call void @PyErr_SetString(ptr nonnull @PyExc_TypeError, ptr nonnull @".const.can't unbox array from PyObject into native value.  The object maybe of a different type")
  br label %entry.endif.endif.endif.endif.endif

entry.endif.endif.endif.endif.endif:              ; preds = %entry.endif.endif.endif.endif.if, %entry.endif.endif.endif.endif
  %.64.fca.0.load = load ptr, ptr %.49, align 8
  %sunkaddr5 = getelementptr inbounds i8, ptr %.49, i64 32
  %.64.fca.4.load = load ptr, ptr %sunkaddr5, align 8
  %sunkaddr6 = getelementptr inbounds i8, ptr %.49, i64 40
  %.64.fca.5.0.load = load i64, ptr %sunkaddr6, align 8
  %sunkaddr7 = getelementptr inbounds i8, ptr %.49, i64 48
  %.64.fca.5.1.load = load i64, ptr %sunkaddr7, align 8
  br i1 %.60, label %arg0.err, label %entry.endif.endif.endif.endif.endif.endif, !prof !0

entry.endif.endif.endif.endif.endif.endif:        ; preds = %entry.endif.endif.endif.endif.endif
  %.73 = load ptr, ptr %.7, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(72) %.74, i8 0, i64 72, i1 false)
  %.78 = call i32 @NRT_adapt_ndarray_from_python(ptr %.73, ptr nonnull %.74)
  %sunkaddr8 = getelementptr inbounds i8, ptr %.74, i64 24
  %.82 = load i64, ptr %sunkaddr8, align 8
  %.83 = icmp ne i64 %.82, 4
  %.84 = icmp ne i32 %.78, 0
  %.85 = or i1 %.84, %.83
  br i1 %.85, label %entry.endif.endif.endif.endif.endif.endif.if, label %entry.endif.endif.endif.endif.endif.endif.endif, !prof !0

arg1.err:                                         ; preds = %entry.endif.endif.endif.endif.endif.endif.endif, %arg2.err
  call void @NRT_decref(ptr %.64.fca.0.load)
  br label %arg0.err

entry.endif.endif.endif.endif.endif.endif.if:     ; preds = %entry.endif.endif.endif.endif.endif.endif
  call void @PyErr_SetString(ptr nonnull @PyExc_TypeError, ptr nonnull @".const.can't unbox array from PyObject into native value.  The object maybe of a different type")
  br label %entry.endif.endif.endif.endif.endif.endif.endif

entry.endif.endif.endif.endif.endif.endif.endif:  ; preds = %entry.endif.endif.endif.endif.endif.endif.if, %entry.endif.endif.endif.endif.endif.endif
  %.89.fca.0.load = load ptr, ptr %.74, align 8
  %sunkaddr9 = getelementptr inbounds i8, ptr %.74, i64 8
  %.89.fca.1.load = load ptr, ptr %sunkaddr9, align 8
  %sunkaddr10 = getelementptr inbounds i8, ptr %.74, i64 16
  %.89.fca.2.load = load i64, ptr %sunkaddr10, align 8
  %sunkaddr11 = getelementptr inbounds i8, ptr %.74, i64 32
  %.89.fca.4.load = load ptr, ptr %sunkaddr11, align 8
  %sunkaddr12 = getelementptr inbounds i8, ptr %.74, i64 40
  %.89.fca.5.0.load = load i64, ptr %sunkaddr12, align 8
  %sunkaddr13 = getelementptr inbounds i8, ptr %.74, i64 48
  %.89.fca.5.1.load = load i64, ptr %sunkaddr13, align 8
  %sunkaddr14 = getelementptr inbounds i8, ptr %.74, i64 56
  %.89.fca.6.0.load = load i64, ptr %sunkaddr14, align 8
  %sunkaddr15 = getelementptr inbounds i8, ptr %.74, i64 64
  %.89.fca.6.1.load = load i64, ptr %sunkaddr15, align 8
  br i1 %.85, label %arg1.err, label %entry.endif.endif.endif.endif.endif.endif.endif.endif, !prof !0

entry.endif.endif.endif.endif.endif.endif.endif.endif: ; preds = %entry.endif.endif.endif.endif.endif.endif.endif
  %.98 = load ptr, ptr %.8, align 8
  %.101 = call ptr @PyNumber_Long(ptr %.98)
  %.102.not = icmp eq ptr %.101, null
  br i1 %.102.not, label %entry.endif.endif.endif.e...endif, label %entry.endif.endif.endif.e...if, !prof !0

arg2.err:                                         ; preds = %entry.endif.endif.endif.e...endif
  call void @NRT_decref(ptr %.89.fca.0.load)
  br label %arg1.err

entry.endif.endif.endif.e...if:                   ; preds = %entry.endif.endif.endif.endif.endif.endif.endif.endif
  %.104 = call i64 @PyLong_AsLongLong(ptr nonnull %.101)
  call void @Py_DecRef(ptr nonnull %.101)
  br label %entry.endif.endif.endif.e...endif

entry.endif.endif.endif.e...endif:                ; preds = %entry.endif.endif.endif.e...if, %entry.endif.endif.endif.endif.endif.endif.endif.endif
  %.99.0 = phi i64 [ %.104, %entry.endif.endif.endif.e...if ], [ 0, %entry.endif.endif.endif.endif.endif.endif.endif.endif ]
  %.109 = call ptr @PyErr_Occurred()
  %.110.not = icmp eq ptr %.109, null
  br i1 %.110.not, label %entry.endif.endif.endif.e...endif.endif, label %arg2.err, !prof !5

entry.endif.endif.endif.e...endif.endif:          ; preds = %entry.endif.endif.endif.e...endif
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(72) %.114, i8 0, i64 72, i1 false)
  %.130 = call i32 @_ZN8__main__15numba_tiled_mulB2v1B38c8tJTIeFIjxB2IKSgI4CrvQClQZ6FczSBAA_3dE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedEx(ptr nonnull %.114, ptr nonnull %excinfo, ptr %.39.fca.0.load, ptr poison, i64 poison, i64 poison, ptr %.39.fca.4.load, i64 %.39.fca.5.0.load, i64 %.39.fca.5.1.load, i64 poison, i64 poison, ptr %.64.fca.0.load, ptr poison, i64 poison, i64 poison, ptr %.64.fca.4.load, i64 %.64.fca.5.0.load, i64 %.64.fca.5.1.load, i64 poison, i64 poison, ptr %.89.fca.0.load, ptr %.89.fca.1.load, i64 %.89.fca.2.load, i64 4, ptr %.89.fca.4.load, i64 %.89.fca.5.0.load, i64 %.89.fca.5.1.load, i64 %.89.fca.6.0.load, i64 %.89.fca.6.1.load, i64 %.99.0) #3
  %.131 = load ptr, ptr %excinfo, align 8
  %0 = load <2 x ptr>, ptr %.114, align 16
  %.140.fca.0.load = load ptr, ptr %.114, align 16
  %sunkaddr16 = getelementptr inbounds i8, ptr %.114, i64 16
  %1 = load <2 x i64>, ptr %sunkaddr16, align 16
  %sunkaddr17 = getelementptr inbounds i8, ptr %.114, i64 32
  %.140.fca.4.load = load ptr, ptr %sunkaddr17, align 16
  %sunkaddr18 = getelementptr inbounds i8, ptr %.114, i64 40
  %2 = load <4 x i64>, ptr %sunkaddr18, align 8
  call void @NRT_decref(ptr %.39.fca.0.load)
  call void @NRT_decref(ptr %.64.fca.0.load)
  call void @NRT_decref(ptr %.89.fca.0.load)
  %cond = icmp eq i32 %.130, 0
  br i1 %cond, label %entry.endif.endif.endif.e...endif.endif.if.endif, label %entry.endif.endif.endif.e...endif.endif.endif.if

entry.endif.endif.endif.e...endif.endif.if.endif: ; preds = %entry.endif.endif.endif.e...endif.endif
  %sunkaddr19 = getelementptr i8, ptr %.14, i64 24
  %.180 = load ptr, ptr %sunkaddr19, align 8
  %.184.not = icmp eq ptr %.180, null
  br i1 %.184.not, label %entry.endif.endif.endif.e...endif.endif.if.endif.else, label %entry.endif.endif.endif.e...endif.endif.if.endif.if

entry.endif.endif.endif.e...endif.endif.if.endif.if: ; preds = %entry.endif.endif.endif.e...endif.endif.if.endif
  %.186 = call ptr @PyList_GetItem(ptr nonnull %.180, i64 0)
  br label %entry.endif.endif.endif.e...endif.endif.if.endif.endif

entry.endif.endif.endif.e...endif.endif.if.endif.else: ; preds = %entry.endif.endif.endif.e...endif.endif.if.endif
  call void @PyErr_SetString(ptr nonnull @PyExc_RuntimeError, ptr nonnull @".const.`env.consts` is NULL in `read_const`")
  br label %entry.endif.endif.endif.e...endif.endif.if.endif.endif

entry.endif.endif.endif.e...endif.endif.if.endif.endif: ; preds = %entry.endif.endif.endif.e...endif.endif.if.endif.else, %entry.endif.endif.endif.e...endif.endif.if.endif.if
  %.181.0 = phi ptr [ %.186, %entry.endif.endif.endif.e...endif.endif.if.endif.if ], [ null, %entry.endif.endif.endif.e...endif.endif.if.endif.else ]
  %.198 = call ptr @numba_unpickle(ptr nonnull @.const.pickledata.128823728961376, i32 32, ptr nonnull @.const.pickledata.128823728961376.sha1)
  store <2 x ptr> %0, ptr %.199, align 16
  %sunkaddr20 = getelementptr inbounds i8, ptr %.199, i64 16
  store <2 x i64> %1, ptr %sunkaddr20, align 16
  %sunkaddr21 = getelementptr inbounds i8, ptr %.199, i64 32
  store ptr %.140.fca.4.load, ptr %sunkaddr21, align 16
  %sunkaddr22 = getelementptr inbounds i8, ptr %.199, i64 40
  store <4 x i64> %2, ptr %sunkaddr22, align 8
  %.203 = call ptr @NRT_adapt_ndarray_to_python_acqref(ptr nonnull %.199, ptr %.198, i32 2, i32 1, ptr %.181.0)
  call void @NRT_decref(ptr %.140.fca.0.load)
  br label %common.ret

entry.endif.endif.endif.e...endif.endif.endif.if: ; preds = %entry.endif.endif.endif.e...endif.endif
  call void @PyErr_Clear()
  %.213 = load { ptr, i32, ptr, ptr, i32 }, ptr %.131, align 8
  %.214 = extractvalue { ptr, i32, ptr, ptr, i32 } %.213, 4
  %.215 = icmp sgt i32 %.214, 0
  %.218 = extractvalue { ptr, i32, ptr, ptr, i32 } %.213, 0
  %.220 = extractvalue { ptr, i32, ptr, ptr, i32 } %.213, 1
  br i1 %.215, label %entry.endif.endif.endif.e...endif.endif.endif.if.if, label %entry.endif.endif.endif.e...endif.endif.endif.if.else

entry.endif.endif.endif.e...endif.endif.endif.if.if: ; preds = %entry.endif.endif.endif.e...endif.endif.endif.if
  %.221 = sext i32 %.220 to i64
  %.222 = call ptr @PyBytes_FromStringAndSize(ptr %.218, i64 %.221)
  %.223 = load { ptr, i32, ptr, ptr, i32 }, ptr %.131, align 8
  %.224 = extractvalue { ptr, i32, ptr, ptr, i32 } %.223, 2
  %.226 = extractvalue { ptr, i32, ptr, ptr, i32 } %.223, 3
  %.228 = call ptr %.226(ptr %.224)
  %.229 = icmp eq ptr %.228, null
  br i1 %.229, label %entry.endif.endif.endif.e...if.1, label %entry.endif.endif.endif.e...endif.1, !prof !0

entry.endif.endif.endif.e...endif.endif.endif.if.else: ; preds = %entry.endif.endif.endif.e...endif.endif.endif.if
  %.242 = extractvalue { ptr, i32, ptr, ptr, i32 } %.213, 2
  %.243 = call ptr @numba_unpickle(ptr %.218, i32 %.220, ptr %.242)
  br label %entry.endif.endif.endif.e...endif.endif.endif.if.endif

entry.endif.endif.endif.e...endif.endif.endif.if.endif: ; preds = %entry.endif.endif.endif.e...endif.1, %entry.endif.endif.endif.e...endif.endif.endif.if.else
  %.245 = phi ptr [ %.233, %entry.endif.endif.endif.e...endif.1 ], [ %.243, %entry.endif.endif.endif.e...endif.endif.endif.if.else ]
  %.246.not = icmp eq ptr %.245, null
  br i1 %.246.not, label %common.ret, label %entry.endif.endif.endif.e...if.2, !prof !0

entry.endif.endif.endif.e...if.1:                 ; preds = %entry.endif.endif.endif.e...endif.endif.endif.if.if
  call void @PyErr_SetString(ptr nonnull @PyExc_RuntimeError, ptr nonnull @".const.Error creating Python tuple from runtime exception arguments")
  br label %common.ret

entry.endif.endif.endif.e...endif.1:              ; preds = %entry.endif.endif.endif.e...endif.endif.endif.if.if
  %.233 = call ptr @numba_runtime_build_excinfo_struct(ptr %.222, ptr nonnull %.228)
  call void @NRT_Free(ptr nonnull %.131)
  br label %entry.endif.endif.endif.e...endif.endif.endif.if.endif

entry.endif.endif.endif.e...if.2:                 ; preds = %entry.endif.endif.endif.e...endif.endif.endif.if.endif
  call void @numba_do_raise(ptr nonnull %.245)
  br label %common.ret
}

declare i32 @PyArg_UnpackTuple(ptr, ptr, i64, i64, ...) local_unnamed_addr

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1

declare void @PyErr_SetString(ptr, ptr) local_unnamed_addr

declare i32 @NRT_adapt_ndarray_from_python(ptr nocapture, ptr nocapture) local_unnamed_addr

declare ptr @PyNumber_Long(ptr) local_unnamed_addr

declare i64 @PyLong_AsLongLong(ptr) local_unnamed_addr

declare void @Py_DecRef(ptr) local_unnamed_addr

declare ptr @PyErr_Occurred() local_unnamed_addr

declare ptr @PyList_GetItem(ptr, i64) local_unnamed_addr

declare ptr @numba_unpickle(ptr, i32, ptr) local_unnamed_addr

declare ptr @NRT_adapt_ndarray_to_python_acqref(ptr nocapture, ptr, i32, i32, ptr) local_unnamed_addr

declare void @PyErr_Clear() local_unnamed_addr

declare ptr @PyBytes_FromStringAndSize(ptr, i64) local_unnamed_addr

declare ptr @numba_runtime_build_excinfo_struct(ptr, ptr) local_unnamed_addr

declare void @NRT_Free(ptr) local_unnamed_addr

declare void @numba_do_raise(ptr) local_unnamed_addr

define { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } @cfunc._ZN8__main__15numba_tiled_mulB2v1B38c8tJTIeFIjxB2IKSgI4CrvQClQZ6FczSBAA_3dE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedEx({ ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.1, { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.2, { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.3, i64 %.4) local_unnamed_addr {
entry:
  %.6 = alloca { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] }, align 8
  %.fca.1.gep = getelementptr inbounds nuw i8, ptr %.6, i64 8
  %.fca.2.gep = getelementptr inbounds nuw i8, ptr %.6, i64 16
  %.fca.3.gep = getelementptr inbounds nuw i8, ptr %.6, i64 24
  %.fca.4.gep = getelementptr inbounds nuw i8, ptr %.6, i64 32
  %.fca.5.0.gep = getelementptr inbounds nuw i8, ptr %.6, i64 40
  %.fca.5.1.gep = getelementptr inbounds nuw i8, ptr %.6, i64 48
  %.fca.6.0.gep = getelementptr inbounds nuw i8, ptr %.6, i64 56
  %.fca.6.1.gep = getelementptr inbounds nuw i8, ptr %.6, i64 64
  %excinfo = alloca ptr, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(72) %.6, i8 0, i64 72, i1 false)
  store ptr null, ptr %excinfo, align 8
  %extracted.meminfo = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.1, 0
  %extracted.data = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.1, 4
  %extracted.shape = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.1, 5
  %.10 = extractvalue [2 x i64] %extracted.shape, 0
  %.11 = extractvalue [2 x i64] %extracted.shape, 1
  %extracted.meminfo.1 = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.2, 0
  %extracted.data.1 = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.2, 4
  %extracted.shape.1 = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.2, 5
  %.14 = extractvalue [2 x i64] %extracted.shape.1, 0
  %.15 = extractvalue [2 x i64] %extracted.shape.1, 1
  %extracted.meminfo.2 = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.3, 0
  %extracted.parent.2 = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.3, 1
  %extracted.nitems.2 = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.3, 2
  %extracted.itemsize.2 = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.3, 3
  %extracted.data.2 = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.3, 4
  %extracted.shape.2 = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.3, 5
  %.18 = extractvalue [2 x i64] %extracted.shape.2, 0
  %.19 = extractvalue [2 x i64] %extracted.shape.2, 1
  %extracted.strides.2 = extractvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %.3, 6
  %.20 = extractvalue [2 x i64] %extracted.strides.2, 0
  %.21 = extractvalue [2 x i64] %extracted.strides.2, 1
  %.22 = call i32 @_ZN8__main__15numba_tiled_mulB2v1B38c8tJTIeFIjxB2IKSgI4CrvQClQZ6FczSBAA_3dE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedE5ArrayIfLi2E1C7mutable7alignedEx(ptr nonnull %.6, ptr nonnull %excinfo, ptr %extracted.meminfo, ptr poison, i64 poison, i64 poison, ptr %extracted.data, i64 %.10, i64 %.11, i64 poison, i64 poison, ptr %extracted.meminfo.1, ptr poison, i64 poison, i64 poison, ptr %extracted.data.1, i64 %.14, i64 %.15, i64 poison, i64 poison, ptr %extracted.meminfo.2, ptr %extracted.parent.2, i64 %extracted.nitems.2, i64 %extracted.itemsize.2, ptr %extracted.data.2, i64 %.18, i64 %.19, i64 %.20, i64 %.21, i64 %.4) #3
  %.23 = load ptr, ptr %excinfo, align 8
  %.32.fca.0.load = load ptr, ptr %.6, align 8
  %.32.fca.1.load = load ptr, ptr %.fca.1.gep, align 8
  %.32.fca.2.load = load i64, ptr %.fca.2.gep, align 8
  %.32.fca.3.load = load i64, ptr %.fca.3.gep, align 8
  %.32.fca.4.load = load ptr, ptr %.fca.4.gep, align 8
  %.32.fca.5.0.load = load i64, ptr %.fca.5.0.gep, align 8
  %.32.fca.5.1.load = load i64, ptr %.fca.5.1.gep, align 8
  %.32.fca.6.0.load = load i64, ptr %.fca.6.0.gep, align 8
  %.32.fca.6.1.load = load i64, ptr %.fca.6.1.gep, align 8
  %inserted.meminfo = insertvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } undef, ptr %.32.fca.0.load, 0
  %inserted.parent = insertvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %inserted.meminfo, ptr %.32.fca.1.load, 1
  %inserted.nitems = insertvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %inserted.parent, i64 %.32.fca.2.load, 2
  %inserted.itemsize = insertvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %inserted.nitems, i64 %.32.fca.3.load, 3
  %inserted.data = insertvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %inserted.itemsize, ptr %.32.fca.4.load, 4
  %.41 = insertvalue [2 x i64] undef, i64 %.32.fca.5.0.load, 0
  %.43 = insertvalue [2 x i64] %.41, i64 %.32.fca.5.1.load, 1
  %inserted.shape = insertvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %inserted.data, [2 x i64] %.43, 5
  %.45 = insertvalue [2 x i64] undef, i64 %.32.fca.6.0.load, 0
  %.47 = insertvalue [2 x i64] %.45, i64 %.32.fca.6.1.load, 1
  %inserted.strides = insertvalue { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %inserted.shape, [2 x i64] %.47, 6
  %.49 = alloca i32, align 4
  store i32 0, ptr %.49, align 4
  %cond = icmp eq i32 %.22, 0
  br i1 %cond, label %common.ret, label %entry.if.if

common.ret:                                       ; preds = %entry, %.52, %entry.if.if.if.if
  %common.ret.op = phi { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } [ zeroinitializer, %entry.if.if.if.if ], [ %inserted.strides, %.52 ], [ %inserted.strides, %entry ]
  ret { ptr, ptr, i64, i64, ptr, [2 x i64], [2 x i64] } %common.ret.op

.52:                                              ; preds = %entry.if.if.endif, %entry.if.if.endif.if
  %.100 = call ptr @PyUnicode_FromString(ptr nonnull @".const.<numba.core.cpu.CPUContext object at 0x752a11bbca10>")
  call void @PyErr_WriteUnraisable(ptr %.100)
  call void @Py_DecRef(ptr %.100)
  call void @numba_gil_release(ptr nonnull %.49)
  br label %common.ret

entry.if.if:                                      ; preds = %entry
  call void @numba_gil_ensure(ptr nonnull %.49)
  call void @PyErr_Clear()
  %.55 = load { ptr, i32, ptr, ptr, i32 }, ptr %.23, align 8
  %.56 = extractvalue { ptr, i32, ptr, ptr, i32 } %.55, 4
  %.57 = icmp sgt i32 %.56, 0
  %.60 = extractvalue { ptr, i32, ptr, ptr, i32 } %.55, 0
  %.62 = extractvalue { ptr, i32, ptr, ptr, i32 } %.55, 1
  br i1 %.57, label %entry.if.if.if, label %entry.if.if.else

entry.if.if.if:                                   ; preds = %entry.if.if
  %.63 = sext i32 %.62 to i64
  %.64 = call ptr @PyBytes_FromStringAndSize(ptr %.60, i64 %.63)
  %.65 = load { ptr, i32, ptr, ptr, i32 }, ptr %.23, align 8
  %.66 = extractvalue { ptr, i32, ptr, ptr, i32 } %.65, 2
  %.68 = extractvalue { ptr, i32, ptr, ptr, i32 } %.65, 3
  %.70 = call ptr %.68(ptr %.66)
  %.71 = icmp eq ptr %.70, null
  br i1 %.71, label %entry.if.if.if.if, label %entry.if.if.if.endif, !prof !0

entry.if.if.else:                                 ; preds = %entry.if.if
  %.84 = extractvalue { ptr, i32, ptr, ptr, i32 } %.55, 2
  %.85 = call ptr @numba_unpickle(ptr %.60, i32 %.62, ptr %.84)
  br label %entry.if.if.endif

entry.if.if.endif:                                ; preds = %entry.if.if.if.endif, %entry.if.if.else
  %.87 = phi ptr [ %.75, %entry.if.if.if.endif ], [ %.85, %entry.if.if.else ]
  %.88.not = icmp eq ptr %.87, null
  br i1 %.88.not, label %.52, label %entry.if.if.endif.if, !prof !0

entry.if.if.if.if:                                ; preds = %entry.if.if.if
  call void @PyErr_SetString(ptr nonnull @PyExc_RuntimeError, ptr nonnull @".const.Error creating Python tuple from runtime exception arguments.1")
  br label %common.ret

entry.if.if.if.endif:                             ; preds = %entry.if.if.if
  %.75 = call ptr @numba_runtime_build_excinfo_struct(ptr %.64, ptr nonnull %.70)
  call void @NRT_Free(ptr nonnull %.23)
  br label %entry.if.if.endif

entry.if.if.endif.if:                             ; preds = %entry.if.if.endif
  call void @numba_do_raise(ptr nonnull %.87)
  br label %.52
}

declare void @numba_gil_ensure(ptr) local_unnamed_addr

declare ptr @PyUnicode_FromString(ptr) local_unnamed_addr

declare void @PyErr_WriteUnraisable(ptr) local_unnamed_addr

declare void @numba_gil_release(ptr) local_unnamed_addr

; Function Attrs: mustprogress nofree noinline norecurse nounwind willreturn memory(argmem: readwrite)
define linkonce_odr void @NRT_incref(ptr %.1) local_unnamed_addr #2 {
.3:
  %.4 = icmp eq ptr %.1, null
  br i1 %.4, label %common.ret, label %.3.endif, !prof !0

common.ret:                                       ; preds = %.3.endif, %.3
  ret void

.3.endif:                                         ; preds = %.3
  %.4.i = atomicrmw add ptr %.1, i64 1 monotonic, align 8
  br label %common.ret
}

; Function Attrs: noinline
define linkonce_odr void @NRT_decref(ptr %.1) local_unnamed_addr #3 {
.3:
  %.4 = icmp eq ptr %.1, null
  br i1 %.4, label %common.ret1, label %.3.endif, !prof !0

common.ret1:                                      ; preds = %.3, %.3.endif
  ret void

.3.endif:                                         ; preds = %.3
  fence release
  %0 = tail call i8 @llvm.x86.atomic.sub.cc.i64(ptr nonnull %.1, i64 1, i32 4)
  %1 = trunc i8 %0 to i1
  br i1 %1, label %.3.endif.if, label %common.ret1, !prof !0

.3.endif.if:                                      ; preds = %.3.endif
  fence acquire
  tail call void @NRT_MemInfo_call_dtor(ptr nonnull %.1)
  ret void
}

; Function Attrs: nounwind
declare i8 @llvm.x86.atomic.sub.cc.i64(ptr, i64, i32 immarg) #4

declare void @NRT_MemInfo_call_dtor(ptr) local_unnamed_addr

attributes #0 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #1 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #2 = { mustprogress nofree noinline norecurse nounwind willreturn memory(argmem: readwrite) }
attributes #3 = { noinline }
attributes #4 = { nounwind }

!0 = !{!"branch_weights", i32 1, i32 99}
!1 = !{i1 true}
!2 = distinct !{!2, !3}
!3 = !{!"llvm.loop.unroll.disable"}
!4 = distinct !{!4, !3}
!5 = !{!"branch_weights", i32 99, i32 1}

================================================================================
